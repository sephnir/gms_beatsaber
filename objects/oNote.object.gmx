<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sNote</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>rot = 0;
image_alpha = 0;
scale = 0;
spd = 2.5;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>audio_play_sound(sndHit,1,0);
ww = sprite_get_width(sprite_index); //we need to know how wide

hh = sprite_get_height(sprite_index); //and how tall our sprite is

chunk = irandom_range(8,12); //this is how big your chunks will be in pixels

for (i=0;i&lt;ww;i+=chunk) { //we loop 4 pixel at a time all the way across
 for (j=0;j&lt;hh;j+=chunk) { //while picking all the vertical pixels in each column
 particle = instance_create(x+i,y+j,oParticle); //we create a particle relative to the object, offset by the proper amount
 particle.spr = sprite_index; //we need to tell the particle which sprite to draw. in this case, it's drawing the sprite of the object that's creating it
 particle.size = chunk;
 if rot = 0{
    particle.direction = random_range(45,135);
 }
 if rot = 1{
    if irandom(2) = 1{
        particle.direction = random_range(315,360);
    }else
        particle.direction = random_range(0,45);
 }
 if rot = 2{
    particle.direction = random_range(225,315);
 }
 if rot = 3{
    particle.direction = random_range(135,225);
 }
 particle.xx = i; //we'll need the particles to have these values so they can draw the right part of the sprite
 particle.yy = j;
 }
 }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Rotation
image_angle = rot * -90;

if collision_line(0,oNoteLine.y,room_width,oNoteLine.y,self,false,false){
    if rot == 0{
        if mouse_check_button(mb_left)&amp;&amp; oMouse.y &lt; oMouse.yprevious-10 &amp;&amp; oMouse.x &lt; oMouse.xprevious + 10 &amp;&amp; oMouse.x &gt; oMouse.xprevious - 10{
            if collision_line(oMouse.x-10,oMouse.y,oMouse.xprevious+10,oMouse.yprevious,self,false,false) &amp;&amp; image_alpha == 1{
                instance_destroy();
            }
        }
    }
    if rot == 1{
        if mouse_check_button(mb_left) &amp;&amp; oMouse.x &gt; oMouse.xprevious+10 &amp;&amp; oMouse.y &lt; oMouse.yprevious + 10 &amp;&amp; oMouse.y &gt; oMouse.yprevious - 10{
            if collision_line(oMouse.x,oMouse.y-10,oMouse.xprevious,oMouse.y+10,self,false,false) &amp;&amp; image_alpha == 1{
                instance_destroy();
            }
        }
    }
    if rot == 2{
        if mouse_check_button(mb_left) &amp;&amp; oMouse.y &gt; oMouse.yprevious+10 &amp;&amp; oMouse.x &lt; oMouse.xprevious + 10 &amp;&amp; oMouse.x &gt; oMouse.xprevious - 10{
            if collision_line(oMouse.x-10,oMouse.y,oMouse.xprevious+10,oMouse.yprevious,self,false,false) &amp;&amp; image_alpha == 1{
                instance_destroy();
            }
        }
    }
    if rot == 3{
        if mouse_check_button(mb_left) &amp;&amp; oMouse.x &lt; oMouse.xprevious-10 &amp;&amp; oMouse.y &lt; oMouse.yprevious + 10 &amp;&amp; oMouse.y &gt; oMouse.yprevious - 10{
            if collision_line(oMouse.x,oMouse.y-10,oMouse.xprevious,oMouse.y+10,self,false,false) &amp;&amp; image_alpha == 1{
                instance_destroy();
            }
        }
    }
}
//Appearance
if image_alpha != 1{
    image_alpha += 0.025;
}
if scale != 1{
    scale += 0.05;
}

//Scale
image_xscale = scale;
image_yscale = scale;


y += spd;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
